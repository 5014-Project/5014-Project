# -*- coding: utf-8 -*-
"""Negotiation Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BqdMir6v2j930v_TomrXvtO_X6EmO2gZ

# Mount Google Drive
"""



"""#Import the required Libraries"""

import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

"""# loads the datasets from the google drive"""

# Define the file path
base_path = "datasets/"

# Load datasets
prediction_data = pd.read_csv(base_path + "prediction_agent_data.csv")
demand_response_data = pd.read_csv(base_path + "demand_response_agent_data.csv")
behavioral_data = pd.read_csv(base_path + "behavioral_agent_data.csv")
facilitating_data = pd.read_csv(base_path + "facilitating_agent_data.csv")

# Display first few rows
print(prediction_data.head())
print(demand_response_data.head())

"""# Merge Data from the Prediction and Demand Response Agents

Since the Negotiation Agent relies on both predicted energy values and grid interactions, let's merge these datasets.

Convert Timestamp to Datetime for Accurate Merging
"""

prediction_data["Timestamp"] = pd.to_datetime(prediction_data["Timestamp"])
demand_response_data["Timestamp"] = pd.to_datetime(demand_response_data["Timestamp"])

"""Ensure House_ID is an Integer"""

prediction_data["House_ID"] = prediction_data["House_ID"].astype(int)
demand_response_data["House_ID"] = demand_response_data["House_ID"].astype(int)

"""Merge Prediction and Demand Response Data"""

merged_data = prediction_data.merge(demand_response_data, on=["Timestamp", "House_ID"], how="inner")

"""Compute Net Energy Need (Buyers & Sellers)"""

merged_data["Energy_Need_kWh"] = (
    merged_data["Predicted_Consumption_kWh"]
    - merged_data["Predicted_Production_kWh"]
    - merged_data["Curtailment_Request_kWh"]
)

"""Identify Buyers & Sellers"""

buyers = merged_data[merged_data["Energy_Need_kWh"] > 0]
sellers = merged_data[merged_data["Energy_Need_kWh"] < 0]

"""Display Buyers and Sellers"""

print("\nBuyers (Homes that Need Energy):")
display(buyers.head())

print("\nSellers (Homes that Have Surplus Energy):")
display(sellers.head())

"""Prepare Data for Box Plot"""

boxplot_data = merged_data[["Predicted_Consumption_kWh", "Predicted_Production_kWh", "Energy_Need_kWh"]]
boxplot_data = boxplot_data.rename(
    columns={
        "Predicted_Consumption_kWh": "Predicted Consumption",
        "Predicted_Production_kWh": "Predicted Production",
        "Energy_Need_kWh": "Energy Need (Surplus/Deficit)"
    }
)

"""Create the Box Plot"""

plt.figure(figsize=(12, 6))
sns.boxplot(data=boxplot_data, palette="coolwarm")
plt.title(" Distribution of Energy Metrics (Consumption, Production, Surplus/Deficit)", fontsize=14)
plt.ylabel("Energy (kWh)", fontsize=12)
plt.xlabel("Energy Metrics", fontsize=12)
plt.grid(True, linestyle="--", alpha=0.5)
plt.show()

"""# Analyzing the Groups

Total Energy Deficit Among Buyers


*   The total energy deficit is the sum of positive Energy_Need_kWh values:
"""

total_deficit = buyers["Energy_Need_kWh"].sum()
print(f"Total Energy Deficit (kWh): {total_deficit:.2f}")

"""Total Energy Surplus Among Sellers


*   The total energy surplus is the sum of negative Energy_Need_kWh values

Note: Since surplus values are negative, they represent energy produced but not consumed.


"""

total_surplus = sellers["Energy_Need_kWh"].sum()
print(f"Total Energy Surplus (kWh): {total_surplus:.2f}")

"""#Matching Buyers with Sellers

To match buyers and sellers based on their surplus and deficit, we can use a simple matching algorithm.
Steps for Matching:


1.   Sort Buyers and Sellers:

    *   Sort buyers by their Energy_Need_kWh (largest deficits first).
    *   Sort sellers by their Energy_Need_kWh (smallest surpluses first).


2.   Iterative Matching:

    *   Match each buyer to sellers until their deficit is met or all sellers are exhausted.
"""

# Sort buyers (largest deficits first) and sellers (smallest surpluses first)
buyers = buyers.sort_values(by="Energy_Need_kWh", ascending=False)
sellers = sellers.sort_values(by="Energy_Need_kWh", ascending=True)

# Initialize matches
matches = []

# Match buyers to sellers
for _, buyer in buyers.iterrows():
    buyer_id = buyer["House_ID"]
    buyer_need = buyer["Energy_Need_kWh"]

    for _, seller in sellers.iterrows():
        seller_id = seller["House_ID"]
        seller_surplus = abs(seller["Energy_Need_kWh"])  # Convert surplus to positive

        if buyer_need <= 0 or seller_surplus <= 0:
            continue

        # Calculate the match amount
        match_amount = min(buyer_need, seller_surplus)

        # Record the match
        matches.append({
            "Buyer_ID": buyer_id,
            "Seller_ID": seller_id,
            "Energy_Transferred_kWh": match_amount
        })

        # Update buyer's and seller's energy need
        buyer_need -= match_amount
        sellers.loc[sellers["House_ID"] == seller_id, "Energy_Need_kWh"] += match_amount

        # Stop matching this buyer if their need is satisfied
        if buyer_need <= 0:
            break

# Convert matches to DataFrame
matches_df = pd.DataFrame(matches)

# Display matches
print("Matches (Top 5):")
display(matches_df.head())

"""# Include Behavioural data

The behavioural agent helps :  prioritize energy consumption -> Ensuring essential appliances (eg: Refrigerators) are powered before trading.

Optimize the demand response -> identifying the flexible appliances that can be turned off or delay.

Improve Trading Efficiency -> Buyer's energy needs should only account for the appliances before purchasing.

Steps to integrate the Behavioural Data



1.   Load Appliance- Level Consumption data.
2.   Classify appliances as Essential, Flexible, or Non- Essential.
3.   Adjust Buyer's Energy needs based on the Energy-Consumption
4.   Refine Buyer-Seller matching to ensure the priority-based trades.
"""

# Display the first few rows of behavioural_data
display(behavioral_data.head())

"""Classify Appliances Based on Priority


*  This step ensures that essential energy needs (e.g., refrigerators, medical devices) are secured before trading.




"""

# Filter only High-Priority Appliances
essential_appliances = behavioral_data[behavioral_data["Priority_Level"] == "High"]

# Sum total energy consumption for essential appliances per house
essential_consumption = essential_appliances.groupby("House_ID")["Appliance_Consumption_kWh"].sum().reset_index()

# Rename the column to avoid KeyError
essential_consumption.rename(columns={"Appliance_Consumption_kWh": "Essential_Appliance_Consumption_kWh"}, inplace=True)

# Verify the output
print("Essential Appliance Consumption Aggregation:")
display(essential_consumption.head())

"""Extract Essential Appliance Consumption


*   Only high-priority appliances (e.g., refrigerators, medical devices) should affect buyers' minimum energy need before trading.


"""

# Filter for High-Priority Appliances
essential_appliances = behavioral_data[behavioral_data["Priority_Level"] == "High"]

# Group by House_ID and sum the total essential appliance consumption
essential_consumption = essential_appliances.groupby("House_ID")["Appliance_Consumption_kWh"].sum().reset_index()

# Rename column to avoid merge conflicts
essential_consumption.rename(columns={"Appliance_Consumption_kWh": "Essential_Appliance_Consumption_kWh"}, inplace=True)

# Display results
print("Aggregated Essential Appliance Consumption:")
display(essential_consumption.head())

"""Merge Essential Consumption Data with Buyers


*   integrate the essential consumption data into the buyers’ dataset.


"""

# Convert House_ID to integer for correct merging
buyers["House_ID"] = buyers["House_ID"].astype(int)
essential_consumption["House_ID"] = essential_consumption["House_ID"].astype(int)

# Merge essential consumption data with buyers
buyers = buyers.merge(essential_consumption, on="House_ID", how="left")

# Fill missing values with 0 (some houses may not have high-priority appliances)
buyers["Essential_Appliance_Consumption_kWh"] = buyers["Essential_Appliance_Consumption_kWh"].fillna(0)

# Verify the merged dataset
print("Buyers Data After Merging Behavioral Data:")
display(buyers.head())

"""Identifying the columns"""

print("Columns in Buyers DataFrame Before Merging:")
print(list(buyers.columns))

"""Keep Only One Version of Essential_Appliance_Consumption_kWh


*   Before deleting columns, check which one has the correct values


"""



"""Adjust Buyers' Energy Needs for Trading


*   Before trading, adjust buyers' energy needs so only non-essential energy is traded.
"""

# Ensure the column exists before calculation
if "Essential_Appliance_Consumption_kWh" in buyers.columns:
    buyers["Non_Essential_Energy_Need"] = buyers["Energy_Need_kWh"] - buyers["Essential_Appliance_Consumption_kWh"]
    buyers["Non_Essential_Energy_Need"] = buyers["Non_Essential_Energy_Need"].clip(lower=0)  # Prevent negative values
    print(" Non-Essential Energy Need calculated successfully!")
else:
    print(" Error: Required column 'Essential_Appliance_Consumption_kWh' is missing.")

"""Ensure That Buyers Still Need Energy


*   After adjusting, check if buyers still have a need for energy to trade.
*   If the values are still 0, buyers no longer need energy, and trading won’t occur.


"""

print("Checking Buyers After Fix:")
print(buyers[["House_ID", "Non_Essential_Energy_Need"]].head())

"""Verify If Buyers Still Need Energy


*  Run this to check if at least some buyers have Non_Essential_Energy_Need > 0
*   Total Buyers with Trading Needs: 0, then buyers don’t need energy, and no trade will happen.


"""

print("Checking Buyers Who Still Need Energy:")
buyers_with_need = buyers[buyers["Non_Essential_Energy_Need"] > 0]
print(f"Total Buyers with Trading Needs: {buyers_with_need.shape[0]}")
display(buyers_with_need.head())

"""Verify If Sellers Have Surplus Energy



*   check if sellers have energy to sell (Energy_Need_kWh < 0)
*   Total Sellers with Surplus Energy: 0, then sellers don’t have any energy to sell, and trading cannot occur.


"""

print("Checking Sellers with Surplus Energy:")
sellers_with_surplus = sellers[sellers["Energy_Need_kWh"] < 0]
print(f"Total Sellers with Surplus Energy: {sellers_with_surplus.shape[0]}")
display(sellers_with_surplus.head())

"""Run Buyer-Seller Matching"""

# Check if valid buyers and sellers exist
if not buyers_with_need.empty and not sellers_with_surplus.empty:
    print(" Buyers and Sellers Exist. Proceeding with Matching...")

    # Sort buyers and sellers
    buyers = buyers_with_need.sort_values(by="Non_Essential_Energy_Need", ascending=False)
    sellers = sellers_with_surplus.sort_values(by="Energy_Need_kWh", ascending=True)

    updated_matches = []  # Initialize matches

    # Perform Buyer-Seller Matching
    for _, buyer in buyers.iterrows():
        buyer_id = buyer["House_ID"]
        buyer_need = buyer["Non_Essential_Energy_Need"]

        for seller_index, seller in sellers.iterrows():
            seller_id = seller["House_ID"]
            seller_surplus = abs(seller["Energy_Need_kWh"])  # Convert to positive

            if buyer_need <= 0 or seller_surplus <= 0:
                continue

            # Match the buyer to this seller
            match_amount = min(buyer_need, seller_surplus)

            # Record trade
            updated_matches.append({
                "Buyer_ID": buyer_id,
                "Seller_ID": seller_id,
                "Energy_Transferred_kWh": match_amount
            })

            # Update buyer need and seller surplus
            buyer_need -= match_amount
            sellers.at[seller_index, "Energy_Need_kWh"] += match_amount  # Reduce seller surplus

            # Stop matching if buyer's need is met
            if buyer_need <= 0:
                break

    # Convert matches to DataFrame
    updated_matches_df = pd.DataFrame(updated_matches)

    # Display results
    print(" Final Buyer-Seller Matches Created:")
    display(updated_matches_df)

else:
    print(" No valid buyers or sellers found. Skipping matching process.")

"""Check whether buyers need energy or not ?"""

if buyers_with_need.empty:
    print(" No buyers need energy. Skipping Facilitating Agent and Auction.")
else:
    print(" Buyers need energy. Proceeding with Matching & Trade Execution...")

"""Artificially create demand so the system runs fully."""

# Force some buyers to have a need for energy (between 1-5 kWh)
buyers.loc[buyers.index[:5], "Non_Essential_Energy_Need"] = np.random.uniform(1, 5, size=5)

# Verify the changes
print("Updated Buyers' Energy Need After Adjustment:")
print(buyers[["House_ID", "Non_Essential_Energy_Need"]].describe())

"""Validate Buyer Demand Before Proceeding"""

buyers_with_need = buyers[buyers["Non_Essential_Energy_Need"] > 0]
print(f" Buyers with energy need: {buyers_with_need.shape[0]}")

"""Buyer-Seller Matching"""

# Filter buyers and sellers
buyers_with_need = buyers[buyers["Non_Essential_Energy_Need"] > 0]
sellers_with_surplus = sellers[sellers["Energy_Need_kWh"] < 0]

# Sort buyers (highest need first) and sellers (smallest surplus first)
buyers_with_need = buyers_with_need.sort_values(by="Non_Essential_Energy_Need", ascending=False)
sellers_with_surplus = sellers_with_surplus.sort_values(by="Energy_Need_kWh", ascending=True)

updated_matches = []  # Initialize matches

# Perform Buyer-Seller Matching
for _, buyer in buyers_with_need.iterrows():
    buyer_id = buyer["House_ID"]
    buyer_need = buyer["Non_Essential_Energy_Need"]

    for seller_index, seller in sellers_with_surplus.iterrows():
        seller_id = seller["House_ID"]
        seller_surplus = abs(seller["Energy_Need_kWh"])  # Convert to positive

        if buyer_need <= 0 or seller_surplus <= 0:
            continue

        # Match the buyer to this seller
        match_amount = min(buyer_need, seller_surplus)

        # Record trade
        updated_matches.append({
            "Buyer_ID": buyer_id,
            "Seller_ID": seller_id,
            "Energy_Transferred_kWh": match_amount
        })

        # Update buyer need and seller surplus
        buyer_need -= match_amount
        sellers_with_surplus.at[seller_index, "Energy_Need_kWh"] += match_amount

        # Stop matching if buyer's need is met
        if buyer_need <= 0:
            break

# Convert matches to DataFrame
updated_matches_df = pd.DataFrame(updated_matches)

# Display results
print("Final Buyer-Seller Matches Created:")
display(updated_matches_df)

"""#Facilitating Agent: Transaction Execution & Logging


*   Once buyers and sellers are matched, the Facilitating Agent will track and validate trades.
"""

# Initialize trade log
trading_log = []

for _, trade in updated_matches_df.iterrows():
    trading_log.append({
        "Transaction_ID": f"T{trade.name}",
        "Buyer_ID": trade["Buyer_ID"],
        "Seller_ID": trade["Seller_ID"],
        "Energy_Transferred_kWh": trade["Energy_Transferred_kWh"],
        "Trade_Status": "Pending"
    })

# Convert to DataFrame
trading_log_df = pd.DataFrame(trading_log)

# Display trade log before execution
print(" Trade Log Before Execution:")
display(trading_log_df)

# Function to execute trades
def execute_trade(trade_log):
    for index, trade in trade_log.iterrows():
        if trade["Energy_Transferred_kWh"] > 0:
            trade_log.at[index, "Trade_Status"] = "Completed"
        else:
            trade_log.at[index, "Trade_Status"] = "Failed"

# Execute trades
execute_trade(trading_log_df)

# Display final trade log
print(" Finalized Trade Log After Execution:")
display(trading_log_df)

"""Auction-Based Pricing (Vickrey Auction )


*   Now, we apply auction-based pricing for all completed trades.

"""

# Filter only completed trades
completed_trades = trading_log_df[trading_log_df["Trade_Status"] == "Completed"]

# Apply Vickrey Auction (Second-Highest Bid Pricing)
completed_trades["Bid_Price_per_kWh"] = np.random.uniform(0.10, 0.30, size=len(completed_trades))  # Buyers' bids
completed_trades["Ask_Price_per_kWh"] = np.random.uniform(0.05, 0.25, size=len(completed_trades))  # Sellers' ask prices

# Final Transaction Price (Second-Highest Bid wins)
completed_trades["Final_Transaction_Price_per_kWh"] = np.minimum(
    completed_trades["Bid_Price_per_kWh"],
    completed_trades["Ask_Price_per_kWh"]
)

# Compute total cost per transaction
completed_trades["Total_Cost"] = completed_trades["Final_Transaction_Price_per_kWh"] * completed_trades["Energy_Transferred_kWh"]

# Display final auction results
print("Auction-Based Pricing Applied:")
display(completed_trades)

"""# Smart Contract Integration for Energy Trading"""